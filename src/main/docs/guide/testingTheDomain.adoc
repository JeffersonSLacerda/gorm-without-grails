With our domain objects complete we will now create some basic tests to show that we can
successfully run a Spring Boot application with GORM. Lets go ahead and edit our Spec
files we created earlier and make use of those extra Spock dependencies that we included.

[source,groovy]
./src/test/groovy/demo/GORMwithoutGrails/domain/MakeSpec.groovy
----
include::{sourceDir}/src/test/groovy/demo/GORMwithoutGrails/domain/MakeSpec.groovy[]
----

[source,groovy]
./src/test/groovy/demo/GORMwithoutGrails/domain/ModelSpec.groovy
----
include::{sourceDir}/src/test/groovy/demo/GORMwithoutGrails/domain/ModelSpec.groovy[]
----

[source,groovy]
./src/test/groovy/demo/GORMwithoutGrails/domain/DriverSpec.groovy
----
include::{sourceDir}/src/test/groovy/demo/GORMwithoutGrails/domain/DriverSpec.groovy[]
----

[source,groovy]
./src/test/groovy/demo/GORMwithoutGrails/domain/VehicleSpec.groovy
----
include::{sourceDir}/src/test/groovy/demo/GORMwithoutGrails/domain/VehicleSpec.groovy[]
----

All our tests are virtually identical sans we are testing different objects.
We start by `extends Specification` from Spock followed by declaring our `HibernateDatastore`.
There are a couple of new annotations

 - @Shared - denotes that the datastore will be shared among all tests in the Spec
 - @AutoCleanup - ensuring that the datastore is disposed of properly
 - @Rollback - ensures any data created during the test is removed

The test themselves are standard Spock tests where we are creating a base instance of our
domain class and saving it. We then check that an object was in fact created.

To execute your new tests and see that everything runs correctly, execute the following
from the top level project directory.

[source,bash]
----
$ ./gradlew test
----

When its complete you should see something like this in your terminal.

image::testResults.png[]

At this point we have shown that it is possible to get GORM working with Spring Boot, and
not only is it possible, its fairly painless to harness this new power. But, we don't want to
stop here as we want to offer the most complete view possible when learning how to connect
new technology. Next we will look at the remaining configuration to getting a full app up
and running.